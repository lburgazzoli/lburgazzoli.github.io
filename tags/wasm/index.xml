<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Wasm on Luca Burgazzoli</title><link>https://lburgazzoli.github.io/tags/wasm/</link><description>Recent content in Wasm on Luca Burgazzoli</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 21 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://lburgazzoli.github.io/tags/wasm/index.xml" rel="self" type="application/rss+xml"/><item><title>Apache Camel alike routing engine written in GoLang pt. 1'</title><link>https://lburgazzoli.github.io/posts/2024-05-21_an_apache_camel_alike_routing_engine_written_in_gom_part_1/</link><pubDate>Tue, 21 May 2024 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2024-05-21_an_apache_camel_alike_routing_engine_written_in_gom_part_1/</guid><description>I recently had some time to continue exploring how to combine some of the technologies I had on my radar for quite a while and I finally got something that - even if it is just a proof of concept / experiment - can finally be shown.
What we will go through in this post is:
Apache Camel alike routing engine written in GoLang Apache Camel K alike controller Embedded WebAssembly engine for extensible and safe message routing and transformation Actors Model OCI Artifacts Notes: the result of this work is by no mean expected to land in the official Apache Camel project or in any Red Hat Integration product Background To get started, let’s have a basic understanding of the components/technologies we are going to mention in this post:</description></item><item><title>Apache Kafka Connect meets Wasm - Part 1</title><link>https://lburgazzoli.github.io/posts/2024-02-01_apache_kafka_connect_meets_wasm_part_1/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2024-02-01_apache_kafka_connect_meets_wasm_part_1/</guid><description>I recently wrote a blog post about adding support for Wasm in Apache Camel with the goal to support WebAssembly as a means to provide custom processing and transformation logic within Apache Camel.
In this post I&amp;rsquo;m going to experiment a little bit about doing the same but for Apache Kafka Connect.
Background To get started, let’s have a basic understanding of the components/technologies we are going to mention in this post:</description></item><item><title>Apache Camel meets Wasm - Part 1</title><link>https://lburgazzoli.github.io/posts/2024-01-14_apache_camel_meets_wasm_part_1/</link><pubDate>Sun, 14 Jan 2024 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2024-01-14_apache_camel_meets_wasm_part_1/</guid><description>I recently stumbled upon a fascinating JavaAdvent article discussing a native WebAssembly runtime for the JVM called Chicory. Intrigued by the potential synergy between WebAssembly and Apache Camel, I decided to experiment with integrating them.
Background To get started, let’s have a basic understanding of the components/technologies we are going to mention in this post:
Apache Camel is an open-source integration framework that provides a set of tools and patterns for facilitating the integration of various applications, systems, and technologies.</description></item></channel></rss>