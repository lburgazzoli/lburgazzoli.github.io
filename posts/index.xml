<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Luca Burgazzoli</title><link>https://lburgazzoli.github.io/posts/</link><description>Recent content in Posts on Luca Burgazzoli</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 14 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://lburgazzoli.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Apache Camel meets Wasm - Part 1</title><link>https://lburgazzoli.github.io/posts/2024-01-14_apache_camel_meets_wasm_part_1/</link><pubDate>Sun, 14 Jan 2024 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2024-01-14_apache_camel_meets_wasm_part_1/</guid><description>I recently stumbled upon a fascinating JavaAdvent article discussing a native WebAssembly runtime for the JVM called Chicory. Intrigued by the potential synergy between WebAssembly and Apache Camel, I decided to experiment with integrating them.
Background To get started, let’s have a basic understanding of the components/technologies we are going to mention in this post:
Apache Camel is an open-source integration framework that provides a set of tools and patterns for facilitating the integration of various applications, systems, and technologies.</description></item><item><title>Apache Camel Pulsar Function, Part 1</title><link>https://lburgazzoli.github.io/posts/2023-06-13-apache-camel-pulsar-function-pt_1/</link><pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2023-06-13-apache-camel-pulsar-function-pt_1/</guid><description>I recently came across an interesting article from DataStax about simplified, low-code friendly data piepelines with Pulsar Function and since I always wanted to learn a little bit more about Apache Pulsar and I&amp;rsquo;ve been working on something similar, I&amp;rsquo;ve started exploring how a Pulsar Function based on Apache Camel would look like.
Background To get started, let&amp;rsquo;s have a basic understanding of Apache Pulsar and Apache Camel:
Apache Pulsar is an open-source, distributed messaging and streaming platform built for the cloud.</description></item><item><title>Adventures in GraalVM: polyglot Camel (k) native routes with Quarkus</title><link>https://lburgazzoli.github.io/posts/2019-03-28-adventures-in-graalvm-polyglot-camel-k-native-routes-with-quarkus/</link><pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2019-03-28-adventures-in-graalvm-polyglot-camel-k-native-routes-with-quarkus/</guid><description>The last blog i wrote[1] was about running integration code written in JavaScript from a Camel application compiled as native executable using SubstrateVM (part of the GraalVM project).
Has something happen since then ? I would say yes:
Camel K
Quarkus
Camel 3 development has finally started
As I’m involved in all the projects above, let see how they can play togheter to deliver a truly amazing cloud native experience.</description></item><item><title>Adventures in GraalVM: invoke Java code from JS in native-image</title><link>https://lburgazzoli.github.io/posts/2018-08-06-adventures-in-graalvm-invoke-java-code-from-js-in-native-image/</link><pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2018-08-06-adventures-in-graalvm-invoke-java-code-from-js-in-native-image/</guid><description>Thre’s a lot of interest about GraalVM’s native-image recently so I give it a try but instead of &amp;#34;just&amp;#34; trying to compile some java code to a native binary I went to the edge trying to make the native binary extensible via JavaScript.
In a Java application make some java objects available to the JS runtime is trivial and you only need to do something like:
try(Context context = Context.</description></item><item><title>Adventures in GraalVM: polyglot Camel routes with native-image</title><link>https://lburgazzoli.github.io/posts/2018-09-04-adventures-in-graalvm-polyglot-camel-routes-with-native-image/</link><pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2018-09-04-adventures-in-graalvm-polyglot-camel-routes-with-native-image/</guid><description>I’ve recently been playing with Camel to leverage JavaScript to define routes[1] and GraalVM to invoke JavaScript from a native image[2] so let’s try to make them working together!
As GraalVM as of RC6 does not (yet) support reflective access from scripting context back to Java world we need to use some proxy object GraalVM SDK provides, something like:
private Proxy createRouteDefinitionProxy(RouteDefinition def) { Map&amp;lt;String, Object&amp;gt; methods = new HashMap&amp;lt;&amp;gt;(); methods.</description></item><item><title> Polyglot Camel Routes</title><link>https://lburgazzoli.github.io/posts/2018-07-29-polyglot-camel-routes/</link><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2018-07-29-polyglot-camel-routes/</guid><description>As I do not like XML so much, I spent some time on a very small project to load routes written in JavaScript or Groovy.
Background When camel runs on top of Spring Boot, it automatically loads routes bounded to spring’s application context as well as xml routes placed in a configurable location so as example, if you add a property like:
camel.springboot.xml-routes = classpath:routes/*.xml Camel will scan the classpath for resources matching routes/*.</description></item><item><title>Apache Camel features spotlight: Cluster Service</title><link>https://lburgazzoli.github.io/posts/2017-10-21-apache-camel-features-spotlight-cluster-service/</link><pubDate>Sat, 21 Oct 2017 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2017-10-21-apache-camel-features-spotlight-cluster-service/</guid><description>In Apache Camel 2.20.0 we have introduced an initial support for native clustering named Camel Cluster Service for which my colleague Nicola Ferraro has wrote a really nice post about how to use this feature to create singleton services on Kubernetes [1], here we are going to talk a little bit more about how the service works.
Concepts Cluster Service is a regular camel service that runs in background and is responsible to manage cluster objects.</description></item><item><title>A camel running in the clouds (part 3)</title><link>https://lburgazzoli.github.io/posts/2017-10-13-a-camel-running-in-the-clouds-part-3/</link><pubDate>Fri, 13 Oct 2017 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2017-10-13-a-camel-running-in-the-clouds-part-3/</guid><description>In a micro-service/cloud oriented architecture it becomes increasingly important to provide a mechanism to detect unhealthy services and an idiomatic way is to provide an health endpoint [1]. Apache Camel 2.20.0 provides an experimental support footnoteref:officialdoc[Official camel Health Check documentation] to probe the state of a Camel integration through a dedicated set of APIs and endpoints.
Health Checks API The APIsfootnoteref:officialdoc[] are available in camel-core and belong to the package org.</description></item><item><title>A camel running in the clouds (part 2)</title><link>https://lburgazzoli.github.io/posts/2017-04-12-a-camel-running-in-the-clouds-part-2/</link><pubDate>Wed, 12 Apr 2017 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2017-04-12-a-camel-running-in-the-clouds-part-2/</guid><description>Meet Camel’s ServiceCall EIP The ServiceCall EIP has been introduced in Camel 2.18.0 to allows calling remote services in a distributed systems looking up informaton about the service to consume from external systems such as Kubernetes, Consul, Etcd or DNS. The ServiceCall EIP has been enhanced in Camel 2.19 to make it more extensible and easier to use.
ServiceCall Concepts The ServiceCall is based on common cloud-concepts:
service discovery to collect services definitions from external systems/registries.</description></item><item><title>A camel running in the clouds</title><link>https://lburgazzoli.github.io/posts/2016-12-21-a-camel-running-in-the-clouds/</link><pubDate>Wed, 21 Dec 2016 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2016-12-21-a-camel-running-in-the-clouds/</guid><description>Camel and Spring Boot Camel supports Spring Boot since Camel 2.15 but in the latest release we have improved Camel to make it a first class citizen of Spring Boot, some notables improvements available as of Camel 2.18 are:
spring boot starters
spring boot auto configuration
spring boot healt check
In Camel 2.19 we’ll furter improve the integration between Camel and Spring Boot and it will include support for Spring Cloud.</description></item><item><title>from("java7:anonymousClasses").to("java8:lambda")</title><link>https://lburgazzoli.github.io/posts/2016-10-27-fromjava7anonymous-classestojava8lambda/</link><pubDate>Thu, 27 Oct 2016 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2016-10-27-fromjava7anonymous-classestojava8lambda/</guid><description>With Camel 2.18 we have introduced a few functional APIs in RouteBuilder so you can leverage lambdas to easily build your routes.
Note this is just the beginning so you should expect more and better functional APIs in the coming versions.
Let’s start writing a simple and intentionally verbose Java 7 route that logs if a number is even or odd.
from(&amp;#34;timer:simple?period=503&amp;#34;) .setBody(exchangeProperty(Exchange.TIMER_FIRED_TIME)) .transform(new ExpressionAdapter() { @Override public Object evaluate(Exchange exchange) { return exchange.</description></item><item><title>def µsvc = Fabric8.apply(karaf).andThen(camel)</title><link>https://lburgazzoli.github.io/posts/2016-10-24-def-svc-fabric8applykarafand-thencamel/</link><pubDate>Mon, 24 Oct 2016 00:00:00 +0000</pubDate><guid>https://lburgazzoli.github.io/posts/2016-10-24-def-svc-fabric8applykarafand-thencamel/</guid><description>Fabric8 is an amazing microservice platform which not only provide all the building blocks needed to effectively impement microservices but also a number of high quality open-source libraries and tools that every developer could leverage to ease the integration with Kubernetes/OpenShift.
Some of the bits fabric8 provides are:
OpenShift/Kubernetes Client
Spring Cloud Kubernetes
Fabric8 Karaf
Fabric8 Maven Plugin
As we are brave, we won’t talk about doing Microservices with Spring Boot but we’ll go with Apache Karaf and Apache Camel.</description></item></channel></rss>